---
title: "How APL Built This Entire Blog While I Watched"
date: "2026-01-23"
excerpt: "A behind-the-scenes look at how my autonomous coding agent APL built this Next.js blog from spec to deployment."
slug: "how-apl-built-this-blog"
tags: ["ai", "automation", "nextjs", "project-showcase"]
thumbnail: "/images/posts/how-apl-built-this-blog/thumbnail.jpg"
hero: "/images/posts/how-apl-built-this-blog/hero.jpg"
published: true
author: "Dakota Smith"
keywords: ["automated blog development", "AI-built website", "nextjs automation", "claude code project", "autonomous development"]
---

The blog you're reading was built almost entirely by an autonomous AI agent. I wrote a spec document. APL—my [Autonomous Phased Looper](/blog/building-apl-autonomous-coding-agent)—did the rest. Here's what that looked like.

## The Starting Point

I had requirements documented in a `CLAUDE.md` file:

- Next.js 16 with App Router and SSG
- Neo-brutalist dark design (thick borders, hard shadows, no rounded corners)
- MDX content with advanced code highlighting
- Lighthouse scores of 98+ across all categories
- WCAG 2.1 AA accessibility compliance
- Giscus comments, Vercel Analytics, full SEO

The spec included color values, typography rules, performance targets, and content structure. Everything APL needed to make decisions.

## The Planning Phase

Using [APL's Tree-of-Thoughts planning architecture](/blog/building-apl-autonomous-coding-agent), I ran:

```bash
/apl Build the complete blog according to CLAUDE.md
```

APL's planner agent analyzed the spec and decomposed it into 6 epics with 47 total stories:

```
Epic 1: Foundation & Project Setup (5 stories)
Epic 2: Advanced Code Highlighting System (4 stories)
Epic 3: Core UI Components & Design System (8 stories)
Epic 4: Blog Pages & Content Display (7 stories)
Epic 5: SEO, Analytics & Comments (7 stories)
Epic 6: Performance Optimization & Deployment (11 stories)
```

The task breakdown included dependency analysis. Epic 3 (UI components) blocked Epic 4 (pages). The code highlighting system was independent and could run in parallel with UI work.

```
Task Dependency Graph (simplified):

Epic 1 ────────────────────────────────────────┐
   │                                            │
   ├── Epic 2 (parallel) ─────────────────────┐│
   │                                           ││
   └── Epic 3 ──── Epic 4 ──── Epic 5 ──── Epic 6
```

Each story had explicit success criteria:

```json
{
  "id": "story_3_04",
  "subject": "Build BlogCard component with neo-brutalist styling",
  "success_criteria": [
    "Component renders title, excerpt, date, tags",
    "4px solid border with #333333 color",
    "Hard shadow offset (4px, 4px) with no blur",
    "Hover state with color transition",
    "Keyboard focusable with visible focus ring",
    "Passes axe accessibility audit"
  ]
}
```

## The Execution Phase

APL worked through the epics in order, with parallelization where dependencies allowed.

### Epic 1: Foundation

The coder agent initialized the Next.js project, configured TypeScript strict mode, set up Tailwind with custom colors, and installed the MDX pipeline.

```bash
# APL's first commands
npx create-next-app@latest . --typescript --tailwind --app
npm install @next/mdx gray-matter
```

It configured `tailwind.config.ts` with the design system colors:

```typescript
// Generated by APL
const config: Config = {
  theme: {
    extend: {
      colors: {
        background: '#0A0A0A',
        surface: '#333333',
        text: '#F5F5F5',
        muted: '#A9A9A9',
      },
      fontFamily: {
        sans: ['Space Grotesk', 'sans-serif'],
      },
      boxShadow: {
        'brutal': '4px 4px 0px 0px #333333',
        'brutal-hover': '6px 6px 0px 0px #333333',
      },
    },
  },
};
```

### Epic 2: Code Highlighting

The Shiki integration required multiple iterations. APL's first attempt used rehype-pretty-code, but the line highlighting syntax conflicted with MDX processing.

The ReAct loop caught this:

```
REASON: rehype-pretty-code throws "Unexpected token" on line highlights
ACT: Switch to direct Shiki integration with custom rehype plugin
OBSERVE: Syntax highlighting works, line numbers render correctly
VERIFY: ✓ Code blocks highlight, ✓ Line numbers visible, ✓ Diff syntax works
```

The final implementation:

```typescript
// lib/shiki.ts - Generated by APL
import { getHighlighter } from 'shiki';

const highlighter = await getHighlighter({
  themes: ['github-dark'],
  langs: ['typescript', 'javascript', 'python', 'rust', 'bash', 'json', 'markdown'],
});

export function highlightCode(code: string, lang: string, meta?: string) {
  const lines = parseMetaString(meta); // {1,3-5} syntax
  return highlighter.codeToHtml(code, {
    lang,
    theme: 'github-dark',
    decorations: lines.map(line => ({
      line,
      classes: ['highlighted-line'],
    })),
  });
}
```

### Epic 3: UI Components

This epic produced 12 components. APL created each one with the neo-brutalist constraints:

```typescript
// components/ui/Button.tsx - Generated by APL
interface ButtonProps {
  children: React.ReactNode;
  variant?: 'primary' | 'secondary';
  onClick?: () => void;
}

export function Button({ children, variant = 'primary', onClick }: ButtonProps) {
  return (
    <button
      onClick={onClick}
      className={cn(
        'px-6 py-3 font-semibold border-4 border-surface',
        'shadow-brutal hover:shadow-brutal-hover',
        'transition-shadow duration-150',
        'focus:outline-none focus:ring-2 focus:ring-text focus:ring-offset-2 focus:ring-offset-background',
        variant === 'primary' && 'bg-text text-background',
        variant === 'secondary' && 'bg-background text-text'
      )}
    >
      {children}
    </button>
  );
}
```

Notice the focus states. APL added them because the spec mentioned WCAG compliance, and the success criteria for each component included "keyboard focusable with visible focus ring."

### Epic 4: Pages

The blog listing and individual post pages came together from the components. APL wired up the MDX pipeline:

```typescript
// app/blog/[slug]/page.tsx - Generated by APL
export async function generateStaticParams() {
  const posts = await getAllPosts();
  return posts.map((post) => ({ slug: post.slug }));
}

export default async function BlogPost({ params }: { params: { slug: string } }) {
  const post = await getPostBySlug(params.slug);
  const MDXContent = await compileMDX(post.content);

  return (
    <article className="max-w-3xl mx-auto">
      <HeroImage src={post.hero} alt={post.title} />
      <header className="mb-12">
        <h1 className="text-5xl font-bold mb-4">{post.title}</h1>
        <PostMeta date={post.date} tags={post.tags} />
      </header>
      <div className="prose prose-invert prose-brutal">
        <MDXContent />
      </div>
    </article>
  );
}
```

### Epic 5: SEO & Comments

APL generated Schema.org JSON-LD for each post type:

```typescript
// lib/seo.ts - Generated by APL
export function generateBlogPostSchema(post: Post) {
  return {
    '@context': 'https://schema.org',
    '@type': 'BlogPosting',
    headline: post.title,
    description: post.excerpt,
    image: `https://dakotasmith.dev${post.hero}`,
    datePublished: post.date,
    author: {
      '@type': 'Person',
      name: 'Dakota Smith',
      url: 'https://dakotasmith.dev/about',
    },
  };
}
```

Giscus integration used lazy loading via IntersectionObserver, exactly as specified:

```typescript
// components/Comments.tsx - Generated by APL
export function Comments() {
  const ref = useRef<HTMLDivElement>(null);
  const [loaded, setLoaded] = useState(false);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setLoaded(true);
          observer.disconnect();
        }
      },
      { rootMargin: '100px' }
    );

    if (ref.current) observer.observe(ref.current);
    return () => observer.disconnect();
  }, []);

  return (
    <div ref={ref} className="mt-16">
      {loaded && <GiscusComponent />}
    </div>
  );
}
```

### Epic 6: Performance

The final epic focused on optimization. APL ran Lighthouse audits after each change:

```
Lighthouse Audit (pre-optimization):
- Performance: 89
- Accessibility: 100
- Best Practices: 100
- SEO: 100

Issues identified:
- LCP: 2.4s (hero image not prioritized)
- Unused CSS: 12KB
```

APL addressed each issue:

1. Added `priority` prop to hero images
2. Configured Tailwind purge for unused styles
3. Implemented font preloading with `next/font`
4. Added blur placeholders for images

```
Lighthouse Audit (post-optimization):
- Performance: 99
- Accessibility: 100
- Best Practices: 100
- SEO: 100

Core Web Vitals:
- LCP: 1.2s ✓
- FID: 12ms ✓
- CLS: 0.02 ✓
```

## The Review Phase

After execution completed, the reviewer agent examined all changes:

```markdown
## Review Summary

### Cross-Task Issues Found: 2
1. Inconsistent import paths (some relative, some alias)
   - Fixed: Standardized to @/ alias throughout

2. Missing error boundary on Comments component
   - Fixed: Added ErrorBoundary wrapper

### Patterns Learned
- Neo-brutalist focus rings: ring-2 ring-text ring-offset-2 ring-offset-background
- Lazy loading threshold: rootMargin 100px works well for comments
- Image priority: Always set priority={true} on above-fold hero images

### Regressions: None detected
```

The learner agent persisted these insights to `.apl/patterns/` for future projects.

## What Required Human Input

APL isn't fully autonomous. I intervened for:

**Design decisions**: The spec said "accent color TBD." I picked the specific neon green after seeing the dark theme in context.

**Content**: APL scaffolded the MDX files but I wrote the actual posts (meta, I know).

**API keys**: Giscus repo ID, Vercel project settings—APL prompted me to provide these.

**Image assets**: Thumbnails and hero images required human creation.

Total human time: about 2 hours across the entire build. Most of that was content and images, not code.

## The Numbers

| Metric | Value |
|--------|-------|
| Total stories executed | 47 |
| Lines of code generated | ~4,200 |
| Components created | 18 |
| APL sessions | 6 (one per epic) |
| Errors requiring retry | 8 |
| Human interventions | 12 |
| Final Lighthouse Performance | 99 |

## What This Means

Building a blog isn't hard. Building a blog with perfect Lighthouse scores, full accessibility, advanced code highlighting, SEO optimization, and a cohesive design system—that's a significant project.

APL compressed weeks of work into hours. Not by cutting corners, but by maintaining context across dozens of interconnected decisions and verifying each one against explicit criteria.

The blog you're reading is proof that autonomous coding works. Not for everything—creativity, content, and judgment remain human. But for translating a clear spec into working software, AI agents have arrived.

Try APL yourself: [twofoldtech-dakota/apl](https://github.com/twofoldtech-dakota/apl)

---

The irony of writing a blog post about how an AI built the blog isn't lost on me. But that's the point: APL handles the mechanical work. I focus on what to say and why it matters. That division of labor is the future of software development.
